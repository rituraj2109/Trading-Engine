import pandas as pd
import ta
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import AverageTrueRange
import numpy as np

class TechnicalAnalysis:
    
    @staticmethod
    def add_indicators(df):
        """
        Adds technical indicators to the dataframe:
        - EMA 20, 50
        - RSI 14
        - MACD
        - ATR
        """
        if df is None or df.empty:
            return df

        # EMA
        ema20 = EMAIndicator(close=df['close'], window=20)
        df['ema_20'] = ema20.ema_indicator()
        
        ema50 = EMAIndicator(close=df['close'], window=50)
        df['ema_50'] = ema50.ema_indicator()
        
        # RSI
        rsi = RSIIndicator(close=df['close'], window=14)
        df['rsi'] = rsi.rsi()
        
        # MACD
        macd = MACD(close=df['close'])
        df['macd'] = macd.macd()
        df['macd_signal'] = macd.macd_signal()
        df['macd_diff'] = macd.macd_diff()
        
        # ATR
        atr = AverageTrueRange(high=df['high'], low=df['low'], close=df['close'], window=14)
        df['atr'] = atr.average_true_range()
        
        # Drop NaN values generated by windows (first 50 rows might have NaNs)
        df = df.dropna()
        
        return df

    @staticmethod
    def get_signal_score(row):
        """
        Generate a technical score from a single row (latest candle).
        Score Range: -5 to +5 (approx)
        """
        score = 0
        
        # EMA Trend
        if row['close'] > row['ema_20'] > row['ema_50']:
            score += 1.0 # Strong Uptrend
        elif row['close'] < row['ema_20'] < row['ema_50']:
            score -= 1.0 # Strong Downtrend
            
        # RSI
        if row['rsi'] < 30:
            score += 1.0 # Oversold (Buy signal)
        elif row['rsi'] > 70:
            score -= 1.0 # Overbought (Sell signal)
            
        # MACD Cross
        if row['macd_diff'] > 0 and row['macd'] > row['macd_signal']:
             score += 0.5 # Bullish momentum
        elif row['macd_diff'] < 0 and row['macd'] < row['macd_signal']:
             score -= 0.5 # Bearish momentum
             
        return score

    @staticmethod
    def _find_swing_points(df, lookback=100):
        """
        Find swing highs and swing lows using pivot logic.
        Returns: (swing_highs_idx, swing_lows_idx, highs, lows, closes)
        """
        n = len(df)
        lb = min(lookback, n)
        
        highs = df['high'].values[-lb:]
        lows = df['low'].values[-lb:]
        closes = df['close'].values[-lb:]
        
        # Find swing highs (local maxima)
        swing_highs = []
        swing_lows = []
        
        order = 5  # bars on each side
        for i in range(order, len(highs) - order):
            # Swing high: higher than neighbors
            if highs[i] == max(highs[i-order:i+order+1]):
                swing_highs.append(i)
            # Swing low: lower than neighbors
            if lows[i] == min(lows[i-order:i+order+1]):
                swing_lows.append(i)
        
        return swing_highs, swing_lows, highs, lows, closes
    
    @staticmethod
    def detect_chart_patterns(df, lookback=100):
        """
        Comprehensive chart pattern detection with all 15 patterns.
        Returns: (patterns_list, total_score, pattern_details_dict)
        
        patterns_list: ['Pattern Name (Bias)', ...]
        total_score: cumulative numeric score
        pattern_details: {pattern_name: {'bias': 'Bullish'/'Bearish'/'Neutral', 'score': +1/-1/0, 'confidence': 0-100}}
        """
        patterns = []
        pattern_details = {}
        total_score = 0.0

        if df is None or df.empty or len(df) < 50:
            return patterns, total_score, pattern_details

        try:
            swing_highs_idx, swing_lows_idx, highs, lows, closes = TechnicalAnalysis._find_swing_points(df, lookback)
            n = len(closes)
            
            # =================================================================
            # 1. HIGHER HIGHS / HIGHER LOWS (Uptrend)
            # =================================================================
            if len(swing_highs_idx) >= 2 and len(swing_lows_idx) >= 2:
                recent_highs = [highs[i] for i in swing_highs_idx[-2:]]
                recent_lows = [lows[i] for i in swing_lows_idx[-2:]]
                
                if recent_highs[-1] > recent_highs[-2] and recent_lows[-1] > recent_lows[-2]:
                    patterns.append('Higher Highs/Higher Lows (Bullish)')
                    pattern_details['Higher Highs/Higher Lows'] = {'bias': 'Bullish', 'score': 1, 'confidence': 80}
                    total_score += 1.0
                    
            # =================================================================
            # 2. LOWER HIGHS / LOWER LOWS (Downtrend)
            # =================================================================
                elif recent_highs[-1] < recent_highs[-2] and recent_lows[-1] < recent_lows[-2]:
                    patterns.append('Lower Highs/Lower Lows (Bearish)')
                    pattern_details['Lower Highs/Lower Lows'] = {'bias': 'Bearish', 'score': -1, 'confidence': 80}
                    total_score -= 1.0
            
            # =================================================================
            # 3. TRENDLINE BREAK
            # =================================================================
            if len(swing_lows_idx) >= 3:
                # Fit trendline through recent swing lows
                x_lows = np.array(swing_lows_idx[-3:])
                y_lows = np.array([lows[i] for i in swing_lows_idx[-3:]])
                if len(x_lows) > 1:
                    slope, intercept = np.polyfit(x_lows, y_lows, 1)
                    # Check if current price breaks below trendline
                    expected_support = slope * (n - 1) + intercept
                    if closes[-1] < expected_support * 0.995:  # 0.5% below trendline
                        patterns.append('Trendline Break (Bearish)')
                        pattern_details['Trendline Break'] = {'bias': 'Bearish', 'score': -1, 'confidence': 70}
                        total_score -= 1.0
            
            if len(swing_highs_idx) >= 3:
                # Fit trendline through recent swing highs
                x_highs = np.array(swing_highs_idx[-3:])
                y_highs = np.array([highs[i] for i in swing_highs_idx[-3:]])
                if len(x_highs) > 1:
                    slope, intercept = np.polyfit(x_highs, y_highs, 1)
                    expected_resistance = slope * (n - 1) + intercept
                    if closes[-1] > expected_resistance * 1.005:  # 0.5% above trendline
                        patterns.append('Trendline Break (Bullish)')
                        pattern_details['Trendline Break'] = {'bias': 'Bullish', 'score': 1, 'confidence': 70}
                        total_score += 1.0
            
            # =================================================================
            # 4. SUPPORT & RESISTANCE BREAK/RETEST
            # =================================================================
            if len(swing_lows_idx) >= 2:
                # Recent support level
                support = np.mean([lows[i] for i in swing_lows_idx[-2:]])
                # Check for break and retest
                recent_prices = closes[-10:]
                if closes[-1] < support * 0.995 and max(recent_prices[-5:]) >= support * 0.998:
                    patterns.append('Support Break (Bearish)')
                    pattern_details['Support Break'] = {'bias': 'Bearish', 'score': -1, 'confidence': 75}
                    total_score -= 1.0
                elif closes[-1] > support * 1.002 and min(recent_prices[-5:]) <= support * 1.005:
                    patterns.append('Support Retest (Bullish)')
                    pattern_details['Support Retest'] = {'bias': 'Bullish', 'score': 1, 'confidence': 75}
                    total_score += 1.0
            
            if len(swing_highs_idx) >= 2:
                resistance = np.mean([highs[i] for i in swing_highs_idx[-2:]])
                recent_prices = closes[-10:]
                if closes[-1] > resistance * 1.005 and min(recent_prices[-5:]) <= resistance * 1.002:
                    patterns.append('Resistance Break (Bullish)')
                    pattern_details['Resistance Break'] = {'bias': 'Bullish', 'score': 1, 'confidence': 75}
                    total_score += 1.0
                elif closes[-1] < resistance * 0.998 and max(recent_prices[-5:]) >= resistance * 0.995:
                    patterns.append('Resistance Retest (Bearish)')
                    pattern_details['Resistance Retest'] = {'bias': 'Bearish', 'score': -1, 'confidence': 75}
                    total_score -= 1.0
            
            # =================================================================
            # 5-7. TRIANGLES (Ascending, Descending, Symmetrical)
            # =================================================================
            if len(swing_highs_idx) >= 3 and len(swing_lows_idx) >= 3:
                x_h = np.array(swing_highs_idx[-3:])
                y_h = np.array([highs[i] for i in swing_highs_idx[-3:]])
                x_l = np.array(swing_lows_idx[-3:])
                y_l = np.array([lows[i] for i in swing_lows_idx[-3:]])
                
                slope_h, _ = np.polyfit(x_h, y_h, 1)
                slope_l, _ = np.polyfit(x_l, y_l, 1)
                
                avg_price = np.mean(closes)
                norm_slope_h = slope_h / avg_price
                norm_slope_l = slope_l / avg_price
                
                # Ascending Triangle: flat resistance, rising support
                if abs(norm_slope_h) < 5e-5 and norm_slope_l > 1e-4:
                    patterns.append('Ascending Triangle (Bullish)')
                    pattern_details['Ascending Triangle'] = {'bias': 'Bullish', 'score': 1, 'confidence': 85}
                    total_score += 1.5
                # Descending Triangle: falling resistance, flat support
                elif norm_slope_h < -1e-4 and abs(norm_slope_l) < 5e-5:
                    patterns.append('Descending Triangle (Bearish)')
                    pattern_details['Descending Triangle'] = {'bias': 'Bearish', 'score': -1, 'confidence': 85}
                    total_score -= 1.5
                # Symmetrical Triangle: converging
                elif norm_slope_h < -5e-5 and norm_slope_l > 5e-5:
                    patterns.append('Symmetrical Triangle (Neutral)')
                    pattern_details['Symmetrical Triangle'] = {'bias': 'Neutral', 'score': 0, 'confidence': 70}
                    total_score += 0.0  # Neutral awaiting breakout
            
            # =================================================================
            # 8-9. BULLISH / BEARISH FLAG
            # =================================================================
            if n >= 40:
                pole = closes[-40:-20]  # Strong move (pole)
                flag = closes[-20:]     # Consolidation (flag)
                
                pole_move = pole[-1] - pole[0]
                flag_range = flag.max() - flag.min()
                flag_slope = (flag[-1] - flag[0]) / len(flag)
                
                # Bullish Flag: after uptrend, slight downward consolidation
                if pole_move > 0 and flag_range / abs(pole_move) < 0.4 and flag_slope < 0:
                    patterns.append('Bullish Flag (Bullish)')
                    pattern_details['Bullish Flag'] = {'bias': 'Bullish', 'score': 1, 'confidence': 80}
                    total_score += 1.0
                # Bearish Flag: after downtrend, slight upward consolidation
                elif pole_move < 0 and flag_range / abs(pole_move) < 0.4 and flag_slope > 0:
                    patterns.append('Bearish Flag (Bearish)')
                    pattern_details['Bearish Flag'] = {'bias': 'Bearish', 'score': -1, 'confidence': 80}
                    total_score -= 1.0
            
            # =================================================================
            # 10. RECTANGLE / RANGE BREAKOUT
            # =================================================================
            if n >= 30:
                range_window = closes[-30:]
                high_range = range_window.max()
                low_range = range_window.min()
                range_size = high_range - low_range
                
                # Check if price is ranging (low volatility)
                std_dev = range_window.std()
                if std_dev / np.mean(range_window) < 0.015:  # Low volatility
                    if closes[-1] > high_range * 1.003:
                        patterns.append('Rectangle Breakout (Bullish)')
                        pattern_details['Rectangle Breakout'] = {'bias': 'Bullish', 'score': 1, 'confidence': 80}
                        total_score += 1.0
                    elif closes[-1] < low_range * 0.997:
                        patterns.append('Rectangle Breakout (Bearish)')
                        pattern_details['Rectangle Breakout'] = {'bias': 'Bearish', 'score': -1, 'confidence': 80}
                        total_score -= 1.0
            
            # =================================================================
            # 11-12. DOUBLE TOP / DOUBLE BOTTOM
            # =================================================================
            if len(swing_highs_idx) >= 2:
                p1, p2 = swing_highs_idx[-2], swing_highs_idx[-1]
                h1, h2 = highs[p1], highs[p2]
                
                if abs(h1 - h2) / max(h1, h2) < 0.008:  # Within 0.8%
                    # Check for valley between peaks
                    valley_idx = lows[p1:p2].argmin() + p1
                    if lows[valley_idx] < min(h1, h2) * 0.98:
                        patterns.append('Double Top (Bearish)')
                        pattern_details['Double Top'] = {'bias': 'Bearish', 'score': -1, 'confidence': 85}
                        total_score -= 1.5
            
            if len(swing_lows_idx) >= 2:
                t1, t2 = swing_lows_idx[-2], swing_lows_idx[-1]
                l1, l2 = lows[t1], lows[t2]
                
                if abs(l1 - l2) / max(abs(l1), abs(l2)) < 0.008:
                    # Check for peak between troughs
                    peak_idx = highs[t1:t2].argmax() + t1
                    if highs[peak_idx] > max(l1, l2) * 1.02:
                        patterns.append('Double Bottom (Bullish)')
                        pattern_details['Double Bottom'] = {'bias': 'Bullish', 'score': 1, 'confidence': 85}
                        total_score += 1.5
            
            # =================================================================
            # 13-14. HEAD & SHOULDERS / INVERSE HEAD & SHOULDERS
            # =================================================================
            if len(swing_highs_idx) >= 3:
                p = swing_highs_idx[-3:]
                h = [highs[i] for i in p]
                
                # Head & Shoulders: middle peak higher, symmetrical shoulders
                if h[1] > h[0] and h[1] > h[2] and abs(h[0] - h[2]) / max(h[0], h[2]) < 0.03:
                    if (h[1] - max(h[0], h[2])) / h[1] > 0.015:  # 1.5% higher
                        patterns.append('Head & Shoulders (Bearish)')
                        pattern_details['Head & Shoulders'] = {'bias': 'Bearish', 'score': -1, 'confidence': 90}
                        total_score -= 2.0
            
            if len(swing_lows_idx) >= 3:
                t = swing_lows_idx[-3:]
                l = [lows[i] for i in t]
                
                # Inverse H&S: middle trough lower, symmetrical shoulders
                if l[1] < l[0] and l[1] < l[2] and abs(l[0] - l[2]) / max(abs(l[0]), abs(l[2])) < 0.03:
                    if (min(l[0], l[2]) - l[1]) / abs(l[1]) > 0.015:
                        patterns.append('Inverse Head & Shoulders (Bullish)')
                        pattern_details['Inverse Head & Shoulders'] = {'bias': 'Bullish', 'score': 1, 'confidence': 90}
                        total_score += 2.0
            
            # =================================================================
            # 15. RISING / FALLING WEDGE
            # =================================================================
            if len(swing_highs_idx) >= 3 and len(swing_lows_idx) >= 3:
                x_h = np.array(swing_highs_idx[-3:])
                y_h = np.array([highs[i] for i in swing_highs_idx[-3:]])
                x_l = np.array(swing_lows_idx[-3:])
                y_l = np.array([lows[i] for i in swing_lows_idx[-3:]])
                
                slope_h, _ = np.polyfit(x_h, y_h, 1)
                slope_l, _ = np.polyfit(x_l, y_l, 1)
                
                avg_price = np.mean(closes)
                norm_slope_h = slope_h / avg_price
                norm_slope_l = slope_l / avg_price
                
                # Rising Wedge: both lines rising, converging (bearish)
                if norm_slope_h > 5e-5 and norm_slope_l > 5e-5 and norm_slope_h < norm_slope_l:
                    patterns.append('Rising Wedge (Bearish)')
                    pattern_details['Rising Wedge'] = {'bias': 'Bearish', 'score': -1, 'confidence': 75}
                    total_score -= 1.0
                # Falling Wedge: both lines falling, converging (bullish)
                elif norm_slope_h < -5e-5 and norm_slope_l < -5e-5 and norm_slope_h > norm_slope_l:
                    patterns.append('Falling Wedge (Bullish)')
                    pattern_details['Falling Wedge'] = {'bias': 'Bullish', 'score': 1, 'confidence': 75}
                    total_score += 1.0
        
        except Exception as e:
            # Fail gracefully
            pass

        return patterns, total_score, pattern_details
